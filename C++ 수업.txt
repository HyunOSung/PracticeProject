보통 부모클래스로 한번에 묶는데

Actor

Tick()
Render()
// 이 부분은 전부 순수 가상함수로, 자식 클래스에서 다시 구현해야 함


맵 상속 변경

맵 헤더에 틱, 렌더 정의
클래스에서 함수 구현

억지로 뭔가를 구현할 필요가 없다.
필요한 것만 구현할 것

틱에서 부모쪽 틱 함수를 호출

기능을 먼저 설계하고 없다면 만들거나 찾아내야 함

렌더에서 

유틸 클래스 생성
SetXY
SetObject

GIT 배시 물어보기



헬로 월드
	- 빌드 환경 설정
	- 제일 간단한 프로그램, 이 프로그램의 구조
상수
자료형
연산자
변수 선언
배열
반복문
조건문
포인터
함수
	- 여기까지가 언어 기본
구조체/클래스
클래스 설계
데이터 모딜링
게임 만들기
상속
다형성(오버라이딩, virtual, override)
클래스 관계(is a, has a)
const, overload
게임 엔진 구조
while(1)
{
	Input()
	Tick()
	Render()
}

알고리즘의 기본 : 시공간 절약
메모리를 더 쓸 것이냐, CPU를 더 쓸 것이냐.

벡터라 한다면 모든 자료가 전부 가능해야 한다

STL 벡터(수학 벡터와 다름)
	크기가 바뀌는 배열(저장소)

벡터의 구현
	자료 저장 공간 - 동적으로 할당이 가능
	크기에 대한 정보
	위치
	
	자료 추가(제일 뒤에 추가)
		동적할당을 하면서 자료를 유지
		- 성능 업, 메모리를 쓴다.
	자료 읽어오기(연산자 오버로딩, [])


템플릿은 헤더 쪽에 전부 집어넣어야 함

inline 물어보기
- 컴파일러가 자동으로 시켜주는 최적화(옵션에 있음)


저장소 생성
저장소에 데이터 집어넣기
저장소에 집어넣은 데이터 삭제
저장소에 집어넣은 특정 데이터 삭제
저장소에 생긴 빈 공간에 데이터 추가



템플릿이란 어떤 형태로든 적용해서 자동으로 컴파일해줄 수 있게 하는 것



메모리 공간을 동적으로 만들어보자.
그래서 한게 배열이었는데 일일히 해줘야 하는 단점이 있다.
그래서 벡터를 구현해보는 것

기본 형태로는 동적 작업이 불가능

컴퓨터 구조상 메모리가 설정되면 늘이는 게 불가능
사이즈가 변화하면 메모리를 옮기고 다시 설정해야 함

규모 설정 - 데이터 입력 - 규모 재설정 - 데이터 복사 - 재할당 - 데이터 추가 및 다시 입력

변수가 같은데 두개가 다르면 차라리 변수를 각각 만들어주기

추가.
	1. 자료 저장소 충분
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록
	2. 자료 저장소 부족
		자료 저장소 늘리기
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록

	//단 조건
		인덱스 범위 체크

번역 ->C++

알고리즘 정당성 증명
반복문 불변식


// 문제 1
////네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.
////그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.
////다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
////
////지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.
////전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다.
////각각 “지도 1”과 “지도 2”라고 하자.지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.
////지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
////“지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.
////암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
////
////입력 형식
////입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.
////
////1 ? n ? 16
////arr1, arr2는 길이 n인 정수 배열로 주어진다.
////정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다.즉, 0 ? x ? 2 ^ n - 1을 만족한다.
////출력 형식
////원래의 비밀지도를 해독하여 "#", 공백으로 구성된 문자열 배열로 출력하라.
//

문제 1
01001 = {' ','#',' ',' ','#'}
공백과 #으로 변환
둘 중 하나가 #이라면 #
둘 다 공백이라면 공백


입력 받은 수가 16이하 1이상인지 확인
입력 받은 수에 따라서 랜덤 배열 2개 생성
	배열 각 인자는 최대(16) 최소값(1)을 따름
각 인자를 2진수로 변환
변환된 인자 비교식


두 배열 비교
신규 배열 출력


//문제 2
//숫자 X보다 크거나 같은 수 중 가장 작은 2의 승수(2^ㅜ)를 NPOT(Next Power of Two)라고 할 때, 주어진 숫자 N개의 NPOT를 구하여 모두 XOR 한 값을 구하시오.
//
//조건
//1<X<2^63
//1<=N<2^18
//
//입력
//3//숫자의 개수
//3
//5
//7
//
//출력
//4
//
//4 = 4^8(4 xor 8 xor 8)


string iterator : 하나하나 전부 검색

scanf로 double이나 float형을 입력 받을 때는 %.1f 등으로 소수점 길이까지 지정을 해서 입력을 받아줘야 하고
printf로 출력을 할 때도 소수점 길이까지 지정을 해서 출력을 해줘야 한다. 

링크드 리스트 중요함, 만들어볼것


스택, 큐

분할정복
- 기능을 최대한 분할해서 구현한 다음에 하나로 합치기


재귀함수, 재귀 알고리즘
- 자기 자신을 호출해야 한다.

% 연산자를 사용하면 해당 값보다 낮은수가 반드시 나온다.
- 나머지를 보여주기 때문
난수 생성은 time.h를 통해서
srand((unsigned int)time(0));


printf("%d %d", (a,b))로 출력하면 왜 값이 이상하게 나오는가?
-()를 하게 되면 인수를 하나로 인식한다.
-, 연산자는 다음 수를 보여주므로 b를 출력하고 남은 곳에는 더미 데이터가 들어가게 된다.

최대공약수 구하기
- 조건이 맞으면 큰수를 더 작은 수로 나눠서 작은 수를 -1씩 해서 계속해서 큰 수를 나눠준다. 나눈 수로 원래 작은 수 원본이 나눠지는 수가 최대 공약수가 된다.

소인수 찾기
- while문 도는 동안 나머지가 0이면 원수를 첫 인수(2)로 나누고 나눈 a를 저장한다. 그리고 나누는데 성공한 인수는 출력하고 그대로 유지한다.
- 만일 나누는데 실패한다면 인수에 1을 더해서 다시 나눈다.
- 체크는 성공한 인수를 따로 받아서 인수들끼리만 곱한 수를 원수와 비교해서 같으면 탈출한다.

파이 무한급수
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int a = 10000;
	float pi = 0;

	for (int j = 0; j < 10; ++j)
	{

		printf("%d\n", a);
		pi = 0;
		for (int i = 0; i < a + 1; ++i)
		{
			float var = 1.0f / ((2.0f*(float)i) + 1.0f);
			if (i % 2 == 0)
			{
				pi = pi + var;
			}
			else
			{
				pi = pi - var;
			}
			if (i != 0 && i % a == 0)
			{
				printf("%f\n", 4.0f * pi);
			}
		}

		a = a + 10000;
	}
	return 0;
}

- 각각 개별로 독립된 값을 구하고 싶다면 루프 처음에 구하고 싶은 대상을 초기화 시켜줘야 한다.




정수 자릿값 더하기
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int SumDigits(long n)
{
	int q = 1;	// 나눗셈을 할 수
	int w = 0;  // 자리수

	bool cal1 = false;
	bool cal2 = false;
	while (cal1 == false)
	{	
		q = q * 10;
		if (n / q == 0)
		{
			q = q / 10;
			while (cal2 == false)
			{
				if (n / q != 0)
				{
					w = w + (n / q);
					n = n % q;
				}
				if (q == 1)
				{
					cal2 = true;					
					n = w;
				}
				q = q  / 10;
			}
			cal1 = true;
		}
	}
	return w;
}

int main()
{
	long a = 0;

	cin >> a;

	a = SumDigits(a);

	cout << a << endl;

	return 0;
}

- 초기화 정말 중요함. 일일히 다 해줘야 함. 잊지 말것


정수 역출력
- 자릿수를 하나하나 다 받아서 역순으로 다시 출력하기

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int ReverseOut(long n)
{
	int q = 1;	// 나눗셈을 할 수
	int w = 0;  // 자리수
	int e = 1;
	int r = 0;

	bool cal1 = false;
	bool cal2 = false;
	while (cal1 == false)
	{	
		q = q * 10;
		if (n / q == 0)
		{
			q = q / 10;
			r = q;
			while (cal2 == false)
			{
				if (n / q > 0)
				{
					w = w + (n / q) * e;
					n = n % q;
				}
				if (e == r)
				{
					cal2 = true;										
				}
				q = q  / 10;
				e = e * 10;
			}
			cal1 = true;
		}
	}
	return w;
}

int main()
{
	long a = 0;

	cin >> a;

	a = ReverseOut(a);

	cout << a << endl;

	return 0;
}

- 이게 큐 구현 같기도 하고...
- 나머지를 구해서 1부터 곱해서 처음에 나눴던 기준수와 동일해질때까지 반복문을 돌려서 자리수 재배치



파이 무한급수 함수

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

float Pi(float n)
{
	float q = 0.0f;

	for (int i = 0; i < n; ++i)
	{
		if (i % 2 != 1)
		{
			q = q + (1.0f / ((2.0f * (float)i) + 1.0f));
		}
		else
		{
			q = q - (1.0f / ((2.0f * (float)i) + 1.0f));
		}
	}
	return 4*q;
}

int main()
{
	float a = 0.0f;

	cin >> a;

	a = Pi(a);

	cout << a << endl;

	return 0;
}


- 함수는 첫 설정때 설정한 데이터 유형만 리턴한다.
- int형으로 설정하면 int형만 리턴하는 방식





//배열 동적 초기화 방법 물어보기
- 반복문으로 일일히 전부 초기화 시켜주는 방법이 있음, 셋팅 때 부터 초기화를 동적으로 할 수는 없음


배열 내 중복체크

자기 자신 스킵(j == k)

자기 자신 제외(j != k)
끝까지 비교를 했을 때 중복이 없으면 출력(a[j] != a[k] && k == 9)
끝까지 비교를 했을 때 중복이 있음(a[j] == a[k])
	뒤에 중복 수가 있음
		앞의 수를 출력
	앞에 중복 수가 있음
		출력하지 않고 패스

배열 1개로 하는 건 일단 중단, 너무 어려움
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int a[10] = {5,2,4,8,9,6,3,4,5,2};




	//for (int i = 0; i < 10; ++i)
	//{
	//	cin >> a[i];
	//}
	for (int j = 0; j < 10; ++j)
	{
		for (int k = j; k < 10; ++k)
		{			
			if (a[j] > a[k])
			{
				int q = a[j];
				a[j] = a[k];
				a[k] = q;
			}
		}		
	}

	for (int i = 0; i < 10; ++i)
	{
		if (a[i] != a[i+1])
		{
			cout << a[i] << endl;
		}
	}
	return 0;

}

- 먼저 소팅을 하고 앞뒤가 다르면 출력하도록 해서 성공.


틱택토 배치 및 검사
#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int a[3][3] = {
	{0,0,0},
	{0,0,0},
	{0,0,0}
};

int main()
{
	srand((unsigned int)time(0));

	int x = 0;
	int y = 0;


	//틱택토 보드 만들기
	for (int i = 0; i < 3; ++i)
	{
		for (int j = 0; j < 3; ++j)
		{
			//틱택토 보드 내에 구성요소 배치
			if (rand() % 2 == 0)
			{
				a[i][j] = { 0 };
				cout << a[i][j] << " | ";
			}
			else
			{
				a[i][j] = { 1 };
				cout << a[i][j] << " | ";
			}
		}
		cout << endl;
	}

	//틱택토 보드 검사
	for (int i = 0; i < 3; ++i)
	{
		if (a[i][0] && a[i][1] && a[i][2] == 1 || 0)
		{
			cout << i << "열은 빙고입니다." << endl;
		}
		
		if (a[0][i] && a[1][i] && a[2][i] == 1 || 0)
		{
			cout << i << "행은 빙고입니다." << endl;
		}
	}




	return 0;
}

- 한 열, 혹은 비교하고 싶은 구성 전체를 동일한 조건으로 통일하고 싶다면 &&가 필요


!!포인터

#include<iostream>
#include<stdio.h>
#include<time.h>

using namespace std;

int main()
{
	int q = 1;
	int *w = &q;

	cout << q << endl; -> 일반 변수 선언 ->1
	cout << w << endl; ->포인터 선언, 주소값만 저장 ->주소
	cout << &q << endl; ->일반 변수의 주소값만 참조 -> 주소
	cout << *w << endl; -> 포인터 변수가 가리키는 주소의 값을 참조해온다. ->1




	return 0;
}


피벗, 파티션 등등
퀵소트 시간복잡도

소팅 별 성능 생각하기

코드는 적게, 성능은 좋게


배열 검사 할 때 값 정확하게 집어 넣어야 함,
우리는 xy로 부르지만 배열 상에선 반대가 된다(y,x)
- 2차원 배열은 세로부터 카운트 한다.

함수 작동 후에 다른 함수가 선언되어있으면 이전 함수에서 해당 함수를 호출하려고 해도 함수 호출이 불가능 하다.



배정민 깃 : baewhv/GitFirst_bjm
https://github.com/baewhv/GitFirst_bjm





































































