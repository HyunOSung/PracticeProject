보통 부모클래스로 한번에 묶는데

Actor

Tick()
Render()
// 이 부분은 전부 순수 가상함수로, 자식 클래스에서 다시 구현해야 함


맵 상속 변경

맵 헤더에 틱, 렌더 정의
클래스에서 함수 구현

억지로 뭔가를 구현할 필요가 없다.
필요한 것만 구현할 것

틱에서 부모쪽 틱 함수를 호출

기능을 먼저 설계하고 없다면 만들거나 찾아내야 함

렌더에서 

유틸 클래스 생성
SetXY
SetObject

GIT 배시 물어보기



헬로 월드
	- 빌드 환경 설정
	- 제일 간단한 프로그램, 이 프로그램의 구조
상수
자료형
연산자
변수 선언
배열
반복문
조건문
포인터
함수
	- 여기까지가 언어 기본
구조체/클래스
클래스 설계
데이터 모딜링
게임 만들기
상속
다형성(오버라이딩, virtual, override)
클래스 관계(is a, has a)
const, overload
게임 엔진 구조
while(1)
{
	Input()
	Tick()
	Render()
}

알고리즘의 기본 : 시공간 절약
메모리를 더 쓸 것이냐, CPU를 더 쓸 것이냐.

벡터라 한다면 모든 자료가 전부 가능해야 한다

STL 벡터(수학 벡터와 다름)
	크기가 바뀌는 배열(저장소)

벡터의 구현
	자료 저장 공간 - 동적으로 할당이 가능
	크기에 대한 정보
	위치
	
	자료 추가(제일 뒤에 추가)
		동적할당을 하면서 자료를 유지
		- 성능 업, 메모리를 쓴다.
	자료 읽어오기(연산자 오버로딩, [])


템플릿은 헤더 쪽에 전부 집어넣어야 함

inline 물어보기
- 컴파일러가 자동으로 시켜주는 최적화(옵션에 있음)


저장소 생성
저장소에 데이터 집어넣기
저장소에 집어넣은 데이터 삭제
저장소에 집어넣은 특정 데이터 삭제
저장소에 생긴 빈 공간에 데이터 추가



템플릿이란 어떤 형태로든 적용해서 자동으로 컴파일해줄 수 있게 하는 것



메모리 공간을 동적으로 만들어보자.
그래서 한게 배열이었는데 일일히 해줘야 하는 단점이 있다.
그래서 벡터를 구현해보는 것

기본 형태로는 동적 작업이 불가능

컴퓨터 구조상 메모리가 설정되면 늘이는 게 불가능
사이즈가 변화하면 메모리를 옮기고 다시 설정해야 함

규모 설정 - 데이터 입력 - 규모 재설정 - 데이터 복사 - 재할당 - 데이터 추가 및 다시 입력

변수가 같은데 두개가 다르면 차라리 변수를 각각 만들어주기

추가.
	1. 자료 저장소 충분
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록
	2. 자료 저장소 부족
		자료 저장소 늘리기
		추가 위치 정보를 한칸 이동
		추가 위치 추가 정보 기록

	//단 조건
		인덱스 범위 체크

번역 ->C++

알고리즘 정당성 증명
반복문 불변식


// 문제 1
////네오는 평소 프로도가 비상금을 숨겨놓는 장소를 알려줄 비밀지도를 손에 넣었다.
////그런데 이 비밀지도는 숫자로 암호화되어 있어 위치를 확인하기 위해서는 암호를 해독해야 한다.
////다행히 지도 암호를 해독할 방법을 적어놓은 메모도 함께 발견했다.
////
////지도는 한 변의 길이가 n인 정사각형 배열 형태로, 각 칸은 “공백”(“ “) 또는 “벽”(“#”) 두 종류로 이루어져 있다.
////전체 지도는 두 장의 지도를 겹쳐서 얻을 수 있다.
////각각 “지도 1”과 “지도 2”라고 하자.지도 1 또는 지도 2 중 어느 하나라도 벽인 부분은 전체 지도에서도 벽이다.
////지도 1과 지도 2에서 모두 공백인 부분은 전체 지도에서도 공백이다.
////“지도 1”과 “지도 2”는 각각 정수 배열로 암호화되어 있다.
////암호화된 배열은 지도의 각 가로줄에서 벽 부분을 1, 공백 부분을 0으로 부호화했을 때 얻어지는 이진수에 해당하는 값의 배열이다.
////
////입력 형식
////입력으로 지도의 한 변 크기 n 과 2개의 정수 배열 arr1, arr2가 들어온다.
////
////1 ? n ? 16
////arr1, arr2는 길이 n인 정수 배열로 주어진다.
////정수 배열의 각 원소 x를 이진수로 변환했을 때의 길이는 n 이하이다.즉, 0 ? x ? 2 ^ n - 1을 만족한다.
////출력 형식
////원래의 비밀지도를 해독하여 "#", 공백으로 구성된 문자열 배열로 출력하라.
//

문제 1
01001 = {' ','#',' ',' ','#'}
공백과 #으로 변환
둘 중 하나가 #이라면 #
둘 다 공백이라면 공백


입력 받은 수가 16이하 1이상인지 확인
입력 받은 수에 따라서 랜덤 배열 2개 생성
	배열 각 인자는 최대(16) 최소값(1)을 따름
각 인자를 2진수로 변환
변환된 인자 비교식


두 배열 비교
신규 배열 출력


//문제 2
//숫자 X보다 크거나 같은 수 중 가장 작은 2의 승수(2^ㅜ)를 NPOT(Next Power of Two)라고 할 때, 주어진 숫자 N개의 NPOT를 구하여 모두 XOR 한 값을 구하시오.
//
//조건
//1<X<2^63
//1<=N<2^18
//
//입력
//3//숫자의 개수
//3
//5
//7
//
//출력
//4
//
//4 = 4^8(4 xor 8 xor 8)


string iterator : 하나하나 전부 검색

scanf로 double이나 float형을 입력 받을 때는 %.1f 등으로 소수점 길이까지 지정을 해서 입력을 받아줘야 하고
printf로 출력을 할 때도 소수점 길이까지 지정을 해서 출력을 해줘야 한다. 

링크드 리스트 중요함, 만들어볼것


스택, 큐

분할정복
- 기능을 최대한 분할해서 구현한 다음에 하나로 합치기


재귀함수, 재귀 알고리즘
- 자기 자신을 호출해야 한다.





